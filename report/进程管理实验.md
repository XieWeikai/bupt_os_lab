# 进程管理实验

## 实验内容

### 背景

现代操作系统基本都是多任务的，在多任务的系统内，当多个进程同时需要使用某一个资源时，可能会出现问题。举一个最简单的例子如下

```c
int count = 0;

void writer(){
  count ++;
}
```

如果多个任务都执行上面的writer代码，多个任务并发执行，则会产生竞争条件，即代码结果和执行顺序有关。出现这种现象是因为上述代码中的`count++`操作并不具有原子性，该操作可以分成好几条指令，大致上来说包括如下几步

```assembly
mov (count地址) ax  # 取count的值
add $1 ax          # +1
mov ax (count地址)  # 放回count
```

容易看出，多任务执行上面三条指令的效果很可能并不是我们想要的结果，如两个进程先后取了count的值，但都还未进行+1放回的操作，则两个进程执行完writer操作后，count只增加了1，而不是我们实际可能想要的增加2.

所以在多任务系统下，若多个进程需要共享资源，就需要有进程间的同步措施。操作系统提供的常见的一些同步工具有:

- 互斥锁
- 信号量
- 条件变量

在本次实验中，将使用信号量来解决进程同步的经典问题:读者写着问题。

---

### 引入

如前面所说，当多个进程同时需要使用一个资源时，对资源的并发操作可能会产生不是预想的结果。各个进程对资源的操作被称为临界区，一种解决同时操作资源产生错误的方法为使用互斥锁，如下

```go
mtx.lock();
//critical section
mtx.unlock();
```

互斥锁的`lock`和`unlock`对外可以看成是原子操作，一旦执行了`lock`后，下一个执行`lock`的进程就会阻塞，直到一次`unlock`被调用，才能再一次`lock`。使用互斥锁可以保证多个进程不能同时进入临界区，从而避免了并发的操作共享资源可能会带来的错误。

但若是对于所有问题均使用上述的方法，可能会产生一些效率问题。例如，在某个场景下，应用程序通过一颗红黑树来维护一些信息。对这些信息的读取操作比修改这些信息的操作频率要高。若是各种操作是并发执行的，显然在对红黑树进行修改操作(即写操作时)，不能有别的任务同时再对该红黑树进行修改操作，这是因为在修改操作时，需要改变红黑树的结构，这期间树内的各个节点的指针、颜色等状态都会改变，若在这之间别的任务也对该红黑树进行修改操作，树的结构和状态此时暂时不是正确的，则会出现非常严重的错误(操作不该操作的内存)，这可能直接导致应用崩溃。同理，在写操作进行时，由于树的状态不正确，对红黑树的读操作也会出现错误。

在上面的场景下，用互斥锁的方法可以解决正确性的问题，只要将对红黑树的读写操作均放入临界区即可。但容易发现，对红黑树的读操作不会改变红黑树的状态，即多个读者同时操作红黑树是可以的。需要避免的是写者和写者同时操作、写者和读者同时操作。而直接简单粗暴的使用互斥锁将读写操作都放在临界区使得读者和读者之间的读操作也变成互斥得了，本来可以并行进行的操作变成了串行的，这将会导致效率降低，尤其是当读操作占比例非常大的时候，并发的读者在读时不得不排队等待资源，这将使效率降低很多。

在接下来的实验中，将使用信号量这一同步工具来解决读者写者问题，使得读者-写者、写者-写者间互斥，但允许读者-读者间的并发操作。